# lab3

**PB20061343 徐奥**

## 特别说明

+ 请助教使用 g++ 编译 2.cpp，2_queue.cpp，3.cpp 和 3_epoll.cpp
+ 2.cpp 是基础版本的多线程多人聊天室，2_queue.cpp 是引入了细粒度锁
+ 3.cpp 是使用 select 实现的 IO 复用聊天室，3_epoll.cpp 是使用 epoll 实现的聊天室



## 实验内容

### 双人聊天室

+ 实现以换行符为分割，
+ 处理 send 无法一次发送所有数据的情况：将 send 的返回值与待发送的消息的长度作比较，如果不相等， 说明没有完全发送， 此时只需要再发送一次。以上过程放入 while 循环中。

### 基于多线程的多人聊天室

+ 简单的多线程聊天室：最多支持 32 个用户同时在线，程序将用户发出的数据以换行符分割为消息

+ 细粒度锁：给每个 client 设置一个**待发送消息队列**。一个 client 收到一条信息后，并不是将其直接 send 到剩下的各个 client，而是加入其他 client 的待发送队列。每个 client 在其待发送队列非空的情况下， 会依次取消息 send 到终端。

  recv 和 send 函数均不需要加锁，需要加锁的操作是：将一条消息加入消息队列、从消息队列取出一条消息，从而避免了对阻塞操作进行加锁。

### 基于 IO 复用的多人聊天室

+ SELECT：使用 select，监控各个 client 的 fd 是否有可读，如果有，那么就可以非阻塞 recv，然后直接 send
+ EPOLL：整体思想与 select 类似，epoll 的实现更高效
